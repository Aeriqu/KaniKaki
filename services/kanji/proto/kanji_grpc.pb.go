// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: services/kanji/proto/kanji.proto

package kanji

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Kanji_GetKanji_FullMethodName             = "/aeriqu.kanikaki.kanji.Kanji/GetKanji"
	Kanji_GetKanjiByLevelRange_FullMethodName = "/aeriqu.kanikaki.kanji.Kanji/GetKanjiByLevelRange"
	Kanji_LoadAllKanji_FullMethodName         = "/aeriqu.kanikaki.kanji.Kanji/LoadAllKanji"
)

// KanjiClient is the client API for Kanji service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KanjiClient interface {
	GetKanji(ctx context.Context, in *KanjiRequest, opts ...grpc.CallOption) (*KanjiResponse, error)
	GetKanjiByLevelRange(ctx context.Context, in *KanjiLevelRangeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[KanjiResponse], error)
	LoadAllKanji(ctx context.Context, in *WaniKaniTokenRequest, opts ...grpc.CallOption) (*LoadKanjiResponse, error)
}

type kanjiClient struct {
	cc grpc.ClientConnInterface
}

func NewKanjiClient(cc grpc.ClientConnInterface) KanjiClient {
	return &kanjiClient{cc}
}

func (c *kanjiClient) GetKanji(ctx context.Context, in *KanjiRequest, opts ...grpc.CallOption) (*KanjiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KanjiResponse)
	err := c.cc.Invoke(ctx, Kanji_GetKanji_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kanjiClient) GetKanjiByLevelRange(ctx context.Context, in *KanjiLevelRangeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[KanjiResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Kanji_ServiceDesc.Streams[0], Kanji_GetKanjiByLevelRange_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[KanjiLevelRangeRequest, KanjiResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kanji_GetKanjiByLevelRangeClient = grpc.ServerStreamingClient[KanjiResponse]

func (c *kanjiClient) LoadAllKanji(ctx context.Context, in *WaniKaniTokenRequest, opts ...grpc.CallOption) (*LoadKanjiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadKanjiResponse)
	err := c.cc.Invoke(ctx, Kanji_LoadAllKanji_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KanjiServer is the server API for Kanji service.
// All implementations must embed UnimplementedKanjiServer
// for forward compatibility.
type KanjiServer interface {
	GetKanji(context.Context, *KanjiRequest) (*KanjiResponse, error)
	GetKanjiByLevelRange(*KanjiLevelRangeRequest, grpc.ServerStreamingServer[KanjiResponse]) error
	LoadAllKanji(context.Context, *WaniKaniTokenRequest) (*LoadKanjiResponse, error)
	mustEmbedUnimplementedKanjiServer()
}

// UnimplementedKanjiServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKanjiServer struct{}

func (UnimplementedKanjiServer) GetKanji(context.Context, *KanjiRequest) (*KanjiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKanji not implemented")
}
func (UnimplementedKanjiServer) GetKanjiByLevelRange(*KanjiLevelRangeRequest, grpc.ServerStreamingServer[KanjiResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetKanjiByLevelRange not implemented")
}
func (UnimplementedKanjiServer) LoadAllKanji(context.Context, *WaniKaniTokenRequest) (*LoadKanjiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadAllKanji not implemented")
}
func (UnimplementedKanjiServer) mustEmbedUnimplementedKanjiServer() {}
func (UnimplementedKanjiServer) testEmbeddedByValue()               {}

// UnsafeKanjiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KanjiServer will
// result in compilation errors.
type UnsafeKanjiServer interface {
	mustEmbedUnimplementedKanjiServer()
}

func RegisterKanjiServer(s grpc.ServiceRegistrar, srv KanjiServer) {
	// If the following call pancis, it indicates UnimplementedKanjiServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Kanji_ServiceDesc, srv)
}

func _Kanji_GetKanji_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KanjiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanjiServer).GetKanji(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kanji_GetKanji_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanjiServer).GetKanji(ctx, req.(*KanjiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kanji_GetKanjiByLevelRange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(KanjiLevelRangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KanjiServer).GetKanjiByLevelRange(m, &grpc.GenericServerStream[KanjiLevelRangeRequest, KanjiResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Kanji_GetKanjiByLevelRangeServer = grpc.ServerStreamingServer[KanjiResponse]

func _Kanji_LoadAllKanji_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaniKaniTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KanjiServer).LoadAllKanji(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kanji_LoadAllKanji_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KanjiServer).LoadAllKanji(ctx, req.(*WaniKaniTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Kanji_ServiceDesc is the grpc.ServiceDesc for Kanji service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Kanji_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "aeriqu.kanikaki.kanji.Kanji",
	HandlerType: (*KanjiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKanji",
			Handler:    _Kanji_GetKanji_Handler,
		},
		{
			MethodName: "LoadAllKanji",
			Handler:    _Kanji_LoadAllKanji_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetKanjiByLevelRange",
			Handler:       _Kanji_GetKanjiByLevelRange_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "services/kanji/proto/kanji.proto",
}
